<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>线</title>
    <style>
        .threeJsOuter {
            width: 800px;
            height: 600px;
        }
    </style>
    <script src="./js/three.js"></script>
    <script src="./js/OrbitControls.js"></script>
</head>
<body>
<div class="threeJsOuter"></div>
<script type="text/javascript">
    var threeWindow = {
        width: 800,
        height: 600
    }
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(undefined, threeWindow.width / threeWindow.height, 0.1, 1000);
    camera.position.x = 10;
    camera.position.y = 10;
    camera.position.z = 10;
    camera.lookAt(scene.position);

    var renderder = new THREE.WebGLRenderer({
        antialias : true //去锯齿
    });
    renderder.setSize(threeWindow.width, threeWindow.height);
    renderder.setClearColor("#c0617b");


    var material = new THREE.MeshBasicMaterial({
        antialias: true,
        color: "#f00"
    });
    let geometry = new THREE.Geometry();
    for(let i=0; i<39; i++) { //39行
        for(let j=0; j<39; j++) { //39列
            let sphere = new THREE.SphereGeometry(2, 15, 10);
            sphere.translate(i * 50 - 950, 0, j * 50 - 950); //这里我们使用Geometry的translate方法将间隔调成50
            geometry.merge(sphere);//结合几何体
        }
    }
    let bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry); //最后将几何体替换成对应的缓冲类型
    const mesh = new THREE.Mesh(bufferGeometry, material);
    scene.add(mesh);

    var axes = new THREE.AxesHelper(30);
    scene.add(axes);

    var controls = new THREE.OrbitControls(camera, renderder.domElement);

    function renderFn() {

        renderder.render(scene, camera);
        controls.update();
        requestAnimationFrame(renderFn)
    }

    renderFn();

    renderder.render(scene, camera);

    document.querySelector(".threeJsOuter").appendChild(renderder.domElement)

</script>
</body>
</html>
