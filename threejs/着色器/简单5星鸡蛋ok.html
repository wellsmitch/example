<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>线</title>
    <style>
        .threeJsOuter {
            width: 800px;
            height: 600px;
        }
    </style>
    <script src="../js/three.js"></script>
    <script src="../js/OrbitControls.js"></script>
</head>
<body>
<div class="threeJsOuter"></div>
<script type="text/javascript">
    var threeWindow = {
        width: 800,
        height: 600
    }
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(undefined, threeWindow.width / threeWindow.height, 0.1, 1000);
    camera.position.x = 10;
    camera.position.y = 10;
    camera.position.z = 10;
    camera.lookAt(scene.position);

    var renderder = new THREE.WebGLRenderer({
        antialias : true //去锯齿
    });
    renderder.setSize(threeWindow.width, threeWindow.height);
    renderder.setClearColor("#c0617b");

    var geom = new THREE.SphereGeometry(10, 30, 20);
    var mate = new THREE.ShaderMaterial({
        vertexShader: `
    varying vec3 vNormal;
    void main() {
                //将attributes的normal通过varying赋值给了向量vNormal
        vNormal = normal;
                // projectionMatrix 是投影变换矩阵 modelViewMatrix 是相机坐标系的变换矩阵 最后我们将y值乘以1.4得到了一个形如鸡蛋的几何体
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position.x, position.y * 1.4, position.z, 1.0 );
    }
    `,
        fragmentShader: `
        //片元着色器同样需要定义varying vec3 vNormal；
    varying vec3 vNormal;
    void main() {
                //vNormal是一个已经归一化的三维向量
        float pr = vNormal.x; //pr红色通道值范围为0~1
        float pg = vNormal.y; //pg绿色通道值范围为0~1
        float pb = vNormal.z; //pb蓝色通道值范围为0~1
        gl_FragColor=vec4(pr, pg, pb, 1.0); //最后设置顶点颜色，点与点之间会自动插值
    }
    `
    })
    var mesh = new THREE.Mesh(geom, mate);
    scene.add(mesh)

    var axes = new THREE.AxesHelper(30);
    scene.add(axes);

    var controls = new THREE.OrbitControls(camera, renderder.domElement);

    function renderFn() {

        renderder.render(scene, camera);
        controls.update();
        requestAnimationFrame(renderFn)
    }

    renderFn();

    renderder.render(scene, camera);

    document.querySelector(".threeJsOuter").appendChild(renderder.domElement)

</script>
</body>
</html>
